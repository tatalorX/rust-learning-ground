// Exercise 097: Modules - Nested Modules
//
// Learning objective: Understand how to structure code using
// nested modules and the module file hierarchy.
//
// Modules can be nested arbitrarily and organized inline,
// in separate files, or in directories with mod.rs.

// Inline nested module
mod garden {
    // Public struct
    pub struct Plant {
        pub name: String,
        height: f64, // private field
    }
    
    impl Plant {
        pub fn new(name: &str, height: f64) -> Self {
            Plant {
                name: name.to_string(),
                height,
            }
        }
        
        pub fn height(&self) -> f64 {
            self.height
        }
        
        pub fn grow(&mut self, amount: f64) {
            self.height += amount;
        }
    }
    
    // Nested module for vegetables
    pub mod vegetables {
        #[derive(Debug)]
        pub struct Tomato {
            pub variety: String,
            ripe: bool,
        }
        
        impl Tomato {
            pub fn new(variety: &str) -> Self {
                Tomato {
                    variety: variety.to_string(),
                    ripe: false,
                }
            }
            
            pub fn ripen(&mut self) {
                self.ripe = true;
            }
            
            pub fn is_ripe(&self) -> bool {
                self.ripe
            }
        }
        
        #[derive(Debug)]
        pub struct Carrot {
            pub length: f64,
        }
    }
    
    // Nested module for flowers
    pub mod flowers {
        #[derive(Debug)]
        pub struct Rose {
            pub color: String,
            thorns: bool,
        }
        
        impl Rose {
            pub fn new(color: &str) -> Self {
                Rose {
                    color: color.to_string(),
                    thorns: true,
                }
            }
            
            pub fn has_thorns(&self) -> bool {
                self.thorns
            }
        }
        
        // Even deeper nesting
        pub mod wildflowers {
            #[derive(Debug)]
            pub struct Daisy;
            
            #[derive(Debug)]
            pub struct Sunflower {
                pub height: f64,
            }
        }
    }
    
    // Module with private submodules
    mod maintenance {
        pub fn water_plants() {
            println!("Watering all plants");
        }
        
        pub fn prune_plants() {
            println!("Pruning plants");
        }
    }
    
    // Public function that uses private module
    pub fn maintain_garden() {
        maintenance::water_plants();
        maintenance::prune_plants();
    }
}

// Module with re-exports for cleaner API
mod api {
    // Re-export commonly used items
    pub use super::garden::Plant;
    pub use super::garden::vegetables::{Tomato, Carrot};
    pub use super::garden::flowers::Rose;
    
    // New item in this module
    pub fn garden_info() {
        println!("Garden API v1.0");
    }
}

// Module demonstrating organization patterns
mod backend {
    // Common types used throughout backend
    pub mod types {
        pub type UserId = u64;
        pub type Timestamp = u64;
        
        #[derive(Debug, Clone)]
        pub struct User {
            pub id: UserId,
            pub name: String,
        }
    }
    
    // Database operations
    pub mod db {
        use super::types::{User, UserId};
        
        pub fn find_user(id: UserId) -> Option<User> {
            // Simulated database lookup
            if id == 1 {
                Some(User { id, name: String::from("Alice") })
            } else {
                None
            }
        }
        
        pub fn save_user(user: &User) {
            println!("Saved user: {:?}", user);
        }
    }
    
    // HTTP handlers
    pub mod handlers {
        use super::types::{User, UserId};
        use super::db;
        
        pub fn get_user(id: UserId) -> Option<User> {
            db::find_user(id)
        }
        
        pub fn create_user(name: &str) -> User {
            let user = User {
                id: 999, // Would be generated by DB
                name: name.to_string(),
            };
            db::save_user(&user);
            user
        }
    }
}

fn main() {
    // TODO: Use items from nested garden module
    println!("=== Garden Module ===");
    let mut plant = garden::Plant::new("Fern", 30.0);
    println!("Plant: {} is {}cm tall", plant.name, plant.height());
    plant.grow(5.0);
    println!("After growing: {}cm", plant.height());
    
    // TODO: Use vegetables submodule
    println!("\n=== Vegetables ===");
    let mut tomato = garden::vegetables::Tomato::new("Roma");
    println!("Tomato: {:?}, ripe: {}", tomato.variety, tomato.is_ripe());
    tomato.ripen();
    println!("After ripening: {}", tomato.is_ripe());
    
    let carrot = garden::vegetables::Carrot { length: 15.0 };
    println!("Carrot: {:?}", carrot);
    
    // TODO: Use flowers submodule
    println!("\n=== Flowers ===");
    let rose = garden::flowers::Rose::new("Red");
    println!("Rose: {:?}, has thorns: {}", rose.color, rose.has_thorns());
    
    // TODO: Use deeply nested wildflowers
    let daisy = garden::flowers::wildflowers::Daisy;
    let sunflower = garden::flowers::wildflowers::Sunflower { height: 200.0 };
    println!("Daisy: {:?}, Sunflower: {:?}", daisy, sunflower);
    
    // TODO: Use garden maintenance (via public function)
    println!("\n=== Maintenance ===");
    garden::maintain_garden();
    
    // TODO: Use the simplified API module
    println!("\n=== API Module ===");
    api::garden_info();
    let plant2 = api::Plant::new("Cactus", 10.0);
    let tomato2 = api::Tomato::new("Cherry");
    println!("Created: {} and {:?}", plant2.name, tomato2.variety);
    
    // TODO: Use backend module
    println!("\n=== Backend Module ===");
    use backend::types::UserId;
    
    let user_id: UserId = 1;
    if let Some(user) = backend::handlers::get_user(user_id) {
        println!("Found user: {:?}", user);
    }
    
    let new_user = backend::handlers::create_user("Bob");
    println!("Created user: {:?}", new_user);
}

// TODO: Complete this function using deeply nested modules
fn create_garden_report() {
    use garden::vegetables::Tomato;
    use garden::flowers::Rose;
    
    let tomato = Tomato::new("Beefsteak");
    let rose = Rose::new("White");
    
    println!("Garden contains: {:?} tomatoes and {:?} roses", 
             tomato.variety, rose.color);
}

// TODO: Create a module that organizes related functionality
mod app {
    // Configuration
    pub mod config {
        pub struct Settings {
            pub debug: bool,
            pub port: u16,
        }
        
        impl Settings {
            pub fn default() -> Self {
                Settings {
                    debug: false,
                    port: 8080,
                }
            }
        }
    }
    
    // Logging
    pub mod logging {
        pub fn info(msg: &str) {
            println!("[INFO] {}", msg);
        }
        
        pub fn error(msg: &str) {
            println!("[ERROR] {}", msg);
        }
    }
    
    // Main application logic
    pub fn run() {
        logging::info("Starting application");
        let _settings = config::Settings::default();
        logging::info("Application started successfully");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_plant_growth() {
        let mut plant = garden::Plant::new("Test", 10.0);
        assert_eq!(plant.height(), 10.0);
        plant.grow(5.0);
        assert_eq!(plant.height(), 15.0);
    }
    
    #[test]
    fn test_tomato() {
        let mut tomato = garden::vegetables::Tomato::new("Test");
        assert!(!tomato.is_ripe());
        tomato.ripen();
        assert!(tomato.is_ripe());
    }
    
    #[test]
    fn test_backend() {
        let user = backend::handlers::create_user("Test");
        assert_eq!(user.name, "Test");
    }
    
    #[test]
    fn test_app() {
        app::logging::info("Test message");
        let settings = app::config::Settings::default();
        assert_eq!(settings.port, 8080);
    }
}
