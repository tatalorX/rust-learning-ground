// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¦€ EXERCISE 166: Pub/Sub System
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ğŸ“š LEARNING OBJECTIVE:
//    Implement a publish-subscribe messaging system with channels
//
// ğŸ¢ REAL-WORLD SCENARIO:
//    Allow different parts of your app to communicate without direct coupling
//
// ğŸ¯ YOUR TASK:
//    Complete the implementation below following the requirements.
//
// ğŸ’¡ HINTS:
//    â€¢ Think about edge cases
//    â€¢ Use appropriate Rust patterns
//    â€¢ Test your implementation thoroughly
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn main() {
    println!("Exercise 166: Pub/Sub System");
    // TODO: Add test cases here
}

// TODO: Implement your solution below

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_functionality() {
        // TODO: Add your test
    }
    
    #[test]
    fn test_edge_cases() {
        // TODO: Test edge cases
    }
}
