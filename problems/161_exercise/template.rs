// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ¦€ EXERCISE 161: Memoization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ğŸ“š LEARNING OBJECTIVE:
//    Add memoization to recursive functions for performance
//
// ğŸ¢ REAL-WORLD SCENARIO:
//    Speed up the Fibonacci calculation by caching previously computed values
//
// ğŸ¯ YOUR TASK:
//    Complete the implementation below following the requirements.
//
// ğŸ’¡ HINTS:
//    â€¢ Think about edge cases
//    â€¢ Use appropriate Rust patterns
//    â€¢ Test your implementation thoroughly
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fn main() {
    println!("Exercise 161: Memoization");
    // TODO: Add test cases here
}

// TODO: Implement your solution below

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_basic_functionality() {
        // TODO: Add your test
    }
    
    #[test]
    fn test_edge_cases() {
        // TODO: Test edge cases
    }
}
